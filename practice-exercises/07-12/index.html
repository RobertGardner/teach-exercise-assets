<!DOCTYPE html>
<html class="writer-html5" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>
      Working With Pointers - Exercise Assets
    </title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css"
    />
    <link href="../../styles.css" rel="stylesheet" /> 
    <script>
      // Current page data
      var mkdocs_page_name = "Working With Pointers";
      var mkdocs_page_input_path = "practice-exercises/07-12/index.md";
      var mkdocs_page_url = null;
    </script>
    
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
    <script>
      hljs.highlightAll();
    </script> 
  </head>
  <body class="wy-body-for-nav" role="document">
    <div class="wy-grid-for-nav">
      <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
        <header>
          <div><p>Practice Exercises</p></div>
        </header>
        <div class="wy-nav-content">
          <div class="rst-content">
            <div
              role="main"
              class="document"
              itemscope="itemscope"
              itemtype="http://schema.org/Article"
            >
              <div class="section" itemprop="articleBody">
                 <h1 id="working-with-pointers">Working With Pointers</h1>
<p>Before we move on to the next challenge, let's talk more about <code>pointers</code> and how they work. In general, pointers are variables that store the memory address of another variable. This concept is more abstract in TypeScript and not as prevalent as in languages like C and C++, where special types and characters are used to declare and work with pointers, such as the <code>*</code> character for declaring a pointer variable and the <code>&amp;</code> character to get the address of a variable.</p>
<p>In TypeScript, pointers are not explicitly used, but the underlying mechanism is still present when dealing with objects and arrays. It is different with primitive values, so we will look at examples of both.</p>
<p>Let's start with primitives, which are strings, numbers, booleans, null, undefined and symbols.</p>
<p>Let's examine a simple example:</p>
<pre><code class="language-js">let a = 1;
let b = a;
console.log(b); // 1
</code></pre>
<p>In this example, we have two variables, <code>a</code> is set to <code>1</code> and <code>b</code> is set to <code>a</code>. If we log <code>b</code> it is <code>1</code>. If we change the value of <code>a</code>, <code>b</code> is not affected. This is because primitive values in TypeScript are assigned by value, not by reference. When you assign <code>a</code> to <code>b</code>, the actual value of <code>a</code> (which is 1) is copied into <code>b</code>. As a result, <code>b</code> becomes an independent copy of the value stored in <code>a</code>, and any subsequent changes made to <code>a</code> will not impact the value stored in <code>b</code>. This behavior is consistent with primitive data types like numbers, strings, and booleans, where each variable holds its own distinct value in memory.</p>
<pre><code class="language-js">let a = 1;
let b = a;
a = 2;
console.log(b); // 1
</code></pre>
<p>Objects and arrays, on the other hand, behave differently. When you assign an object or an array to another variable, you are actually copying the reference to the object or array, not the actual value. This means that both variables will point to the same memory location where the object or array is stored. Consequently, if you modify the contents of the object or array using one variable, the changes will be reflected when accessing the object or array through the other variable.</p>
<p>Let's look at an example:</p>
<pre><code class="language-js">const c = { name: &quot;John&quot; };
const d = c;
console.log(d.name); // John
</code></pre>
<p><code>d</code> now points to the same area in memory as <code>c</code>. If we log <code>d.name</code>, we get John.</p>
<p>If we change the value of <code>c.name</code> to Brad and then log <code>d.name</code>, you will see that <code>d.name</code> is now Brad as well. This is because we copied the reference, not the actual value.</p>
<pre><code class="language-js">const c = { name: &quot;John&quot; };
const d = c;
c.name = &quot;Brad&quot;;
console.log(d.name); // Brad
</code></pre>
<h2 id="fast-and-slow-pointer-pattern">Fast and Slow Pointer Pattern</h2>
<p>There are different patterns when it comes to pointers. One of the most common patterns is the <code>fast and slow pointer</code> pattern. This pattern is used to solve problems where you need to find a certain node or element in a linked list or array. Remember, nodes are objects, so they are passed by reference.</p>
<p>The idea of this pattern is that the pointers start at the same point, but one pointer moves faster than the other. The faster pointer moves at twice the speed of the slower pointer. When the faster pointer reaches the end of the list, the slower pointer will be at the middle node.</p>
<p><img src="../images/fastslow.png" width="500" alt="" /></p>
<p>let's look at a quick example:</p>
<pre><code class="language-js">function findMiddle(head: LinkedList): Node | undefined {
  let slow = head; // slow pointer
  let fast = head; // fast pointer

  while (fast !== undefined &amp;&amp; fast.next !== undefined) {
    fast = fast.next.next; // moves two nodes at a time
    slow = slow.next; // moves one node at a time
  }

  return slow; // returns the middle node
}
</code></pre>
<p>This <code>findMiddle</code> function takes in the head of a linked list and returns the middle node. The function uses two pointers, <code>slow</code> and <code>fast</code>, to traverse the linked list. The <code>slow</code> pointer moves one node at a time because of the <code>slow.next</code> assignment, while the <code>fast</code> pointer moves two nodes at a time because of the <code>fast.next.next</code> assignment.</p>
<p>When the <code>fast</code> pointer reaches the end of the list, the <code>slow</code> pointer will be at the middle node.</p>
<p>In the next lesson, we are going to implement a find middle function using the <code>LinkedList</code> class that we created.</p> 
              </div>
            </div>
          </div>
        </div>
      </section>
    </div>
    <script src="../../js/jquery-3.6.0.min.js"></script>
    <script>
      var base_url = "../..";
    </script>
    <script src="../../js/theme_extra.js"></script>
    <script src="../../js/theme.js"></script> <script src="../../search/main.js"></script>
    <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
    </script>
  </body>
</html>
